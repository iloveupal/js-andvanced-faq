# Ответы на продвинутые вопросы по Javascript

Данный рид предназначен для тех, кто хочет знать больше о спецификации языка и сдавать всякие тесты по знанию javascript на 100%.
Конечно, lodash или underscore обладает более широким функционалом и рекомендуется к использованию, но иногда знание простых вещей
в стандарте будет спасать от велосипедоконструирования, паники при необходимости использовать slice; давать более ясное понимание языка)

-------------------

##### Содержание 
- [call, apply & bind](#callapplybind)
- [fibonacci](#fibonacci)
- [setTimeout & setInterval](#timeout)


-------------------

<a name="callapplybind"/>

## call, apply & bind

- Методы call, apply, bind привязывают к функции контекст. 
- Разница между call и apply заключается в способе передачи аргументов.
- bind возвращает новую функцию с заданным контекстом, которую можно будет вызвать позже

``` javascript
introduce = (name,profession) => {
    console.log(`My name is ${name} and my profession is ${profession}`); 
}

introduce('Derek','musician'); 
introduce.call(this,'Derek','musician');
introduce.apply(this,['Derek','musician']);
introduce.bind(this)('Derek','musician');
//Все 4 примера выведут в консоль: 
//My name is Derek and my profession is musician
```

*Неочевидное применение apply:* возможность использовать функции, которые принимают список параметро
но не принимают массив. Например, Math.max
``` javascript
let arr = [1,3,5,7];
Math.max(arr); //NaN 
Math.max.apply(null,arr); //7
``` 
Конечно, в новой спецификации лучше использовать оператор ```...```

*Каррирование и частичное применение:* возможность создавать функцию с предзаданными аргументами: 
``` javascript
let arr = [{_id: 1, items: ['books']}, {_id: 5, items: ['apples','oranges']}, {_id: 6, items: []}];
let get = (property, document) => return document[property];
//DRY
let ids = arr.map(get('_id'); // [1,5,6]
let items = arr.map(get('items')); // [['books'],['apples','oranges'],[]]
//вместо
let ids = arr.map(document => return document._id);
let items = arr.map(document => return document.items);
```


<a name="fibonacci"/>

##Fibonacci

В данном примере будет рассмотрено два паттерна: кеширование и defer. 
Допустим, у нас есть функция, время выполнения которой занимает большое время.
Кеширование решает проблему повторного использования функции с теми же аргументами. 
По сути мы создаем статический map и записываем в него результаты таким образом: 
аргумент - значение. Каждый раз, вызывая функцию, мы проверяем, есть ли уже значение 
для данных аргументов. Это работает при условии, что функция *однозначна для данного аргумента*.

Так как js однопоточен, то очень здорово было бы не замораживать UI долгими вычислениями. 
В js можно отодвигать выполнение функции в конец очереди, и мы будем разделять нашу задачу на несколько маленьких частей
и отодвигать их в конец очереди, чтобы не замораживать ui. КЛАССНО, ДА??!

```javascript
var deferFibonacci = (n) => {
  if (!deferFibonacci.cache)
    deferFibonacci.cache = {};
  console.log('n = ', n);
  if (n < 2) return Promise.resolve(1);
	
  if (!!deferFibonacci.cache[n]) return Promise.resolve(deferFibonacci.cache[n])
	//сихнронный вариант
  var calculus = resolve => {
    var a;
    deferFibonacci(n - 1).then(
      res => {
        a = res;
        deferFibonacci.cache[n - 1] = a;
        return deferFibonacci(n - 2)
      }
    ).then(
      res => {
        deferFibonacci.cache[n - 2] = res;
        deferFibonacci.cache[n] = a + res;
        resolve(a + res)
      }
    )
  };
	//асинхронный
  var deffered = function(resolve) {
    setTimeout(calculus, 0, resolve);
  }
	//возвращаем главный промис
  return new Promise(deffered);
};
//ui не тормозит
deferFibonacci(145).then(res => console.log(res))
```


<a name="timeout"/>

## setTimeout & setInterval

*Если в js все выполняется в одном потоке, то как могут работать такие вещи, как setTimeout и setInterval?*

В js процесс выполнения программы организован в цикл событий (далее - ЦС). Одно событие - один проход ЦС. 
Грубо говоря, программа на js, в которой не происходит никаких асинхронных вызовов или обработки событий
выполняется за один проход ЦС. Функция, переданная в setTimeout или setInterval гарантированно *не выполнится* в 
текущем проходе ЦС. 

``` javascript 
  setTimeout(function(){
    //1 будет выведена в следующем проходе ЦС
    console.log(1);
  },0);
  //это выполнится в текущем проходе ЦС
  console.log(2);
  //цикл выполнится в текущем проходе ЦС несмотря на свою длительность
  for (var i = 0; i < 10000000000; i++);
  //это тоже выполнится в текущем проходе ЦС
  console.log(3);
  
  
  //вывод: 231
```

*могу ли я рассчитывать на то, что setTimeout(fn,n) выполнится через ровно n миллисекунд?*

Нет. Единственное, что в этом случае гарантирует setTimeout, это вызов функции не раньше, чем n миллисекунд. 

*Что влияет на фактическое время вызова?* 

То, что находится в очереди выполнения в текущем проходе ЦС. Например, в следующем примере функция setTimeout не вызовется никогда

``` javascript
  setTimeout(fn,100);
  while(true);
```

Еще один пример, хорошо иллюстрирующий принцип работы setTimeout:

``` javascript 
  setTimeout(fn,100);
  
  //какие-то действия, выполнение которых занимает 150 мс.
```

Здесь fn вызовется не раньше, чем через 150 мс. Не 250, не 100. 150.

*Сохраняется ли событие, которое было вызвано в момент обработки циклом событий каких-либо массивных вычислений?*

Да, сохраняется и будет обработано, когда цикл освободится, при условии, что есть обработчики этого события.

*Как гарантировать выполнение чего-либо каждые n миллисекунд, например двигать секундную стрелку?*

Никак. Есть только рекомендации на этот счет: избегать выполнения тяжелых задач целиком, разбивая их на мелкие.
Сложные задачи также можно обрабатывать с помощью Webworkers. 
